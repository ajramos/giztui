# üöÄ Gu√≠a Maestra para Crear TUI Profesionales al Estilo k9s

**Fecha de an√°lisis:** 7 de agosto de 2025  
**Basado en:** An√°lisis exhaustivo del c√≥digo fuente de k9s

---

## üìã Contexto y Objetivos

Esta gu√≠a proporciona un blueprint completo para crear Terminal User Interfaces (TUI) profesionales usando los mismos patrones arquitect√≥nicos y de dise√±o que k9s (Kubernetes CLI). La aplicaci√≥n resultante ser√° robusta, extensible y mantendr√° una excelente experiencia de usuario.

## üèóÔ∏è Arquitectura Principal

### 1. **Estructura Fundamental de Capas**

```
Aplicaci√≥n TUI
‚îú‚îÄ‚îÄ üì± Capa de UI (internal/ui/)
‚îÇ   ‚îú‚îÄ‚îÄ App (aplicaci√≥n principal)
‚îÇ   ‚îú‚îÄ‚îÄ Pages (gestor de p√°ginas/vistas)
‚îÇ   ‚îú‚îÄ‚îÄ Componentes b√°sicos (Table, Tree, Menu, Prompt)
‚îÇ   ‚îî‚îÄ‚îÄ Dialogs (modales y confirmaciones)
‚îú‚îÄ‚îÄ üé≠ Capa de Vista (internal/view/)
‚îÇ   ‚îú‚îÄ‚îÄ Vistas espec√≠ficas de recursos
‚îÇ   ‚îú‚îÄ‚îÄ Gesti√≥n de comandos y navegaci√≥n
‚îÇ   ‚îî‚îÄ‚îÄ Extenders de funcionalidad
‚îú‚îÄ‚îÄ üé® Capa de Renderizado (internal/render/)
‚îÇ   ‚îú‚îÄ‚îÄ Renderizadores por tipo de recurso
‚îÇ   ‚îú‚îÄ‚îÄ Sistema de colores din√°mico
‚îÇ   ‚îî‚îÄ‚îÄ Formateo y presentaci√≥n
‚îú‚îÄ‚îÄ ‚öôÔ∏è Capa de Configuraci√≥n (internal/config/)
‚îÇ   ‚îú‚îÄ‚îÄ Skins y temas visuales
‚îÇ   ‚îú‚îÄ‚îÄ Hotkeys y aliases
‚îÇ   ‚îî‚îÄ‚îÄ Configuraci√≥n de contexto
‚îî‚îÄ‚îÄ üìä Capa de Modelo (internal/model/)
    ‚îú‚îÄ‚îÄ Gesti√≥n de estado
    ‚îú‚îÄ‚îÄ Listeners y observadores
    ‚îî‚îÄ‚îÄ Buffers de comando
```

### 2. **Componente App Principal**

Implementar una clase App que:

```go
type App struct {
    *tview.Application           // Biblioteca TUI base
    Configurator                 // Sistema de configuraci√≥n
    Main         *Pages          // Gestor de p√°ginas
    flash        *Flash          // Sistema de notificaciones
    actions      *KeyActions     // Gesti√≥n de atajos de teclado
    views        map[string]Primitive  // Registro de vistas
    cmdBuff      *FishBuff       // Buffer de comandos
    running      bool            // Estado de ejecuci√≥n
}
```

**Funcionalidades clave:**
- Gesti√≥n del ciclo de vida de la aplicaci√≥n
- Sistema de actualizaci√≥n as√≠ncrona (`QueueUpdate`, `QueueUpdateDraw`)
- Manejo centralizado de eventos de teclado
- Configuraci√≥n din√°mica de estilos y temas

### 3. **Sistema de P√°ginas y Navegaci√≥n**

```go
type Pages struct {
    *tview.Pages    // Control de p√°ginas de tview
    *Stack          // Pila de navegaci√≥n
}
```

**Caracter√≠sticas:**
- Stack de navegaci√≥n para ir hacia atr√°s/adelante
- Soporte para di√°logos modales superpuestos
- Transiciones suaves entre vistas
- Persistencia del estado de navegaci√≥n

## üé® Sistema de Renderizado y Colores

### 1. **Coloreado Din√°mico**

Implementar `ColorerFunc` que eval√∫a el estado de cada fila:

```go
type ColorerFunc func(namespace string, header Header, rowEvent *RowEvent) tcell.Color

// Ejemplo de implementaci√≥n
func PodColorerFunc() ColorerFunc {
    return func(ns string, h Header, re *RowEvent) tcell.Color {
        statusIdx, _ := h.IndexOf("STATUS", true)
        status := strings.TrimSpace(re.Row.Fields[statusIdx])
        
        switch status {
        case "Running":
            return StdColor
        case "Pending":
            return PendingColor
        case "Error", "Failed":
            return ErrColor
        default:
            return DefaultColor
        }
    }
}
```

### 2. **Sistema de Colores Din√°mico - Arquitectura de 3 Niveles**

k9s implementa un sofisticado sistema de colores que opera en tres niveles jer√°rquicos, permitiendo temas personalizables y colores din√°micos basados en el estado de los recursos.

#### **üé® Nivel 1: Configuraci√≥n YAML (Temas/Skins)**

Los colores se definen en archivos YAML de temas ubicados en `skins/`:

```yaml
# Ejemplo: skins/dracula.yaml
k9s:
  body:
    fgColor: "#f8f8f2"          # Color de texto principal
    bgColor: "#282a36"          # Color de fondo principal
    logoColor: "#bd93f9"        # Color del logo

  frame:
    border:
      fgColor: "#44475a"        # Color de bordes normales
      focusColor: "#6272a4"     # Color de bordes con foco
    
    status:
      newColor: "#50fa7b"       # Recursos nuevos (verde)
      modifyColor: "#ffb86c"    # Recursos modificados (naranja)
      addColor: "#8be9fd"       # Recursos a√±adidos (cyan)
      errorColor: "#ff5555"     # Recursos con error (rojo)
      highlightColor: "#f1fa8c" # Recursos destacados (amarillo)
      killColor: "#ff79c6"      # Recursos eliminados (magenta)
      completedColor: "#6272a4" # Recursos completados (gris)

  views:
    table:
      fgColor: "#f8f8f2"
      bgColor: "#282a36"
      cursorColor: "#bd93f9"    # Color del cursor/selecci√≥n
      header:
        fgColor: "#50fa7b"      # Headers de tabla
        bgColor: "#282a36"
```

#### **‚öôÔ∏è Nivel 2: Aplicaci√≥n Global (tview.Styles)**

Los colores se aplican globalmente al framework tview en el m√©todo `Update()`:

```go
// internal/config/styles.go
func (s *Styles) Update() {
    // Aplicar colores base a tview
    tview.Styles.PrimitiveBackgroundColor = s.BgColor()
    tview.Styles.PrimaryTextColor = s.FgColor()
    tview.Styles.BorderColor = s.K9s.Frame.Border.FgColor.Color()
    tview.Styles.FocusColor = s.K9s.Frame.Border.FocusColor.Color()
    tview.Styles.TitleColor = s.FgColor()
    
    // Actualizar variables globales para renderizadores
    model1.ModColor = s.K9s.Frame.Status.ModifyColor.Color()
    model1.AddColor = s.K9s.Frame.Status.AddColor.Color()
    model1.PendingColor = s.K9s.Frame.Status.PendingColor.Color()
    model1.ErrColor = s.K9s.Frame.Status.ErrorColor.Color()
    model1.StdColor = s.FgColor()
    model1.HighlightColor = s.K9s.Frame.Status.HighlightColor.Color()
    model1.KillColor = s.K9s.Frame.Status.KillColor.Color()
    model1.CompletedColor = s.K9s.Frame.Status.CompletedColor.Color()
    
    // Notificar cambios a todos los componentes
    s.fireStylesChanged()
}
```

#### **üñåÔ∏è Nivel 3: Colores Din√°micos por Estado (ColorerFunc)**

Cada renderizador implementa una funci√≥n `ColorerFunc` que determina el color de cada fila seg√∫n su estado:

```go
// Ejemplo: internal/render/pod.go
func (*Pod) ColorerFunc() model1.ColorerFunc {
    return func(ns string, h model1.Header, re *model1.RowEvent) tcell.Color {
        // Color base por defecto
        c := model1.DefaultColorer(ns, h, re)
        
        // Buscar columna STATUS
        idx, ok := h.IndexOf("STATUS", true)
        if !ok {
            return c
        }
        
        // Aplicar color seg√∫n el estado espec√≠fico
        status := strings.TrimSpace(re.Row.Fields[idx])
        switch status {
        case "Pending", "ContainerCreating":
            return model1.PendingColor      // Amarillo/Naranja
        case "Running":
            if c != model1.ErrColor {
                return model1.StdColor      // Color normal
            }
        case "Terminating":
            return model1.KillColor         // Rojo/Magenta
        case "Completed":
            return model1.CompletedColor    // Gris
        case "Error", "Failed":
            return model1.ErrColor          // Rojo intenso
        }
        
        return c
    }
}
```

#### **üîß Implementaci√≥n en Tu TUI**

Para implementar este sistema en tu aplicaci√≥n:

**1. Crear estructura de colores:**
```go
// internal/render/colorer.go
type EmailColorer struct{}

func (EmailColorer) ColorerFunc() func(email *Email, column string) tcell.Color {
    return func(email *Email, column string) tcell.Color {
        switch strings.ToUpper(column) {
        case "STATUS":
            if email.IsUnread {
                return UnreadColor    // Azul para no le√≠do
            }
            return ReadColor          // Gris para le√≠do
            
        case "FROM":
            if email.IsUnread {
                return tcell.ColorYellow  // Remitente destacado
            }
            return tcell.ColorWhite
            
        case "SUBJECT":
            if email.IsImportant {
                return ImportantColor     // Rojo para importante
            }
            if email.IsUnread {
                return tcell.ColorWhite   // Blanco brillante
            }
            return tcell.ColorGray        // Gris para le√≠do
        }
        return tcell.ColorWhite
    }
}
```

**2. Aplicar colores en las vistas:**
```go
// En tu tabla/lista
func (el *EmailList) updateRow(email *Email, row int) {
    colorer := el.colorer.ColorerFunc()
    
    // Aplicar color a cada celda seg√∫n su columna
    statusColor := colorer(email, "STATUS")
    fromColor := colorer(email, "FROM")
    subjectColor := colorer(email, "SUBJECT")
    
    el.SetCell(row, 0, tview.NewTableCell(status).SetTextColor(statusColor))
    el.SetCell(row, 1, tview.NewTableCell(from).SetTextColor(fromColor))
    el.SetCell(row, 2, tview.NewTableCell(subject).SetTextColor(subjectColor))
}
```

**3. Reaccionar a cambios de tema:**
```go
// Implementar StyleListener
func (el *EmailList) StylesChanged(s *config.Styles) {
    // Actualizar colores cuando cambia el tema
    el.updateColors()
    el.refreshTable()
}
```

**‚úÖ Ventajas de esta arquitectura:**
- **Temas completamente personalizables**
- **Colores que reflejan el estado en tiempo real**
- **Cambio de tema sin reiniciar**
- **Coherencia visual en toda la aplicaci√≥n**
- **Extensibilidad para nuevos tipos de contenido**

**Implementar:**
- Cargado din√°mico de temas desde archivos YAML
- Validaci√≥n con JSON Schema
- Sistema de listeners para cambios de estilo
- Variables globales de color sincronizadas
- ColorerFunc espec√≠ficas por tipo de recurso

## ‚å®Ô∏è Sistema de Eventos y Navegaci√≥n

### 1. **Gesti√≥n de Teclas**

```go
type KeyActions struct {
    actions map[tcell.Key]KeyAction
    mx      sync.RWMutex
}

type KeyAction struct {
    Description string
    Action      ActionHandler
    Opts        ActionOpts  // visible, shared, plugin, etc.
}
```

**Patrones de implementaci√≥n:**
- Mapeo jer√°rquico de teclas (global ‚Üí vista ‚Üí componente)
- Acciones compartidas vs espec√≠ficas
- Sistema de hints din√°mico para mostrar atajos disponibles
- Soporte para combinaciones de teclas (Ctrl+, Shift+, etc.)

### 2. **Patr√≥n de Keyboard Handling**

```go
func (c *Component) keyboard(evt *tcell.EventKey) *tcell.EventKey {
    if action, ok := c.actions.Get(AsKey(evt)); ok {
        return action.Action(evt)
    }
    return evt  // Propagar evento si no se maneja
}
```

### 3. **Sistema de Comandos**

Implementar un prompt inteligente con:
- Autocompletado fuzzy
- Historial de comandos
- Sugerencias contextuales
- Validaci√≥n en tiempo real
- Modo comando vs modo filtro

## üîß Sistema de Configuraci√≥n

### 1. **Hotkeys Personalizables**

```yaml
hotKeys:
  shift-0:
    shortCut: "Shift-0"
    description: "View Workloads"
    command: "workload"
    keepHistory: true
```

### 2. **Aliases de Comandos**

```yaml
aliases:
  po: "v1/pods"
  svc: "v1/services"
  deploy: "apps/v1/deployments"
```

### 3. **Configuraci√≥n por Contexto**

- Archivos de configuraci√≥n separados por entorno
- Merge autom√°tico de configuraciones globales y espec√≠ficas
- Validaci√≥n con JSON Schema
- Recarga en caliente sin reiniciar

## üìä Componentes UI Esenciales

### 1. **Tabla Inteligente**

```go
type Table struct {
    *SelectTable
    gvr          *GVR           // Identificador del recurso
    sortCol      SortColumn     // Columna de ordenamiento
    actions      *KeyActions    // Acciones espec√≠ficas
    cmdBuff      *FishBuff      // Buffer de filtros
    colorerFn    ColorerFunc    // Funci√≥n de coloreado
    decorateFn   DecorateFunc   // Decorador de filas
}
```

**Caracter√≠sticas:**
- Ordenamiento multi-columna
- Filtrado fuzzy en tiempo real
- Selecci√≥n m√∫ltiple con marcadores
- Paginaci√≥n autom√°tica
- Coloreado din√°mico por estado
- Acciones contextuales por fila

### 2. **Sistema de Di√°logos**

Tipos de di√°logos necesarios:
- **Confirmaci√≥n:** Para acciones destructivas
- **Error:** Con mascota ASCII (vaca) para hacer los errores amigables
- **Prompt:** Para entrada de datos
- **Selecci√≥n:** Listas de opciones
- **Transferencia:** Barras de progreso

### 3. **Menu de Navegaci√≥n**

Menu din√°mico que muestra:
- Atajos disponibles por contexto
- Descripci√≥n de acciones
- Agrupaci√≥n inteligente por categor√≠as
- Resaltado de acciones peligrosas

## üîÑ Gesti√≥n de Estado y Modelos

### 1. **Patr√≥n Observer**

```go
type TableListener interface {
    TableDataChanged(*TableData)
    TableLoadFailed(error)
    TableNoData(*TableData)
}
```

### 2. **Buffers de Comando**

```go
type CmdBuff struct {
    buff       []rune
    suggestion string
    listeners  map[BuffWatcher]struct{}
    kind       BufferKind  // Command vs Filter
    active     bool
}
```

### 3. **Gesti√≥n de Focus**

Sistema para manejar el focus entre componentes:
- Stack de focus para navegaci√≥n con Tab
- Restauraci√≥n autom√°tica al volver de di√°logos
- Indicadores visuales claros de focus
- Manejo de focus en layouts complejos

## üéØ Patrones de Implementaci√≥n Espec√≠ficos

### 1. **Factory Pattern para Vistas**

```go
type MetaViewer struct {
    viewerFn func(*GVR) ResourceViewer
}

type MetaViewers map[*GVR]MetaViewer

func loadCustomViewers() MetaViewers {
    m := make(MetaViewers, 30)
    m[PodGVR] = MetaViewer{viewerFn: NewPod}
    m[ServiceGVR] = MetaViewer{viewerFn: NewService}
    // ... m√°s vistas
    return m
}
```

### 2. **Sistema de Extensions**

```go
type ActionExtender interface {
    BindKeys(ResourceViewer)
}

// Extenders espec√≠ficos:
// - LogsExtender: Para ver logs
// - PortForwardExtender: Para port forwarding  
// - ScaleExtender: Para escalar recursos
// - RestartExtender: Para reiniciar
```

### 3. **Renderizado Modular**

```go
type Renderer interface {
    Header(namespace string) Header
    Render(object any, namespace string, row *Row) error
    ColorerFunc() ColorerFunc
}
```

## üöÄ Recomendaciones de Implementaci√≥n

### 1. **Tecnolog√≠as Base**
- **Go + tview:** Para la base TUI (como k9s)
- **tcell:** Para manejo low-level de terminal
- **YAML:** Para configuraci√≥n
- **JSON Schema:** Para validaci√≥n

## üì¶ M√≥dulos de Go Utilizados por k9s

### **Bibliotecas TUI Core**

```go
// Interfaz de usuario terminal principal
github.com/derailed/tview v0.8.5        // Framework TUI principal (fork de rivo/tview)
github.com/derailed/tcell/v2 v2.3.1-rc.4 // Control de terminal low-level (fork de gdamore/tcell)

// Utilidades de terminal
github.com/mattn/go-runewidth v0.0.16   // Manejo de ancho de caracteres Unicode
github.com/mattn/go-colorable v0.1.14   // Soporte de color cross-platform
github.com/atotto/clipboard v0.1.4      // Acceso al portapapeles del sistema
```

### **Configuraci√≥n y Archivos**

```go
// Configuraci√≥n YAML/JSON
gopkg.in/yaml.v3 v3.0.1                 // Parser/serializer YAML
github.com/xeipuuv/gojsonschema v1.2.0   // Validaci√≥n JSON Schema

// Archivos y sistema
github.com/adrg/xdg v0.5.3               // Directorios est√°ndar XDG
github.com/fsnotify/fsnotify v1.9.0      // Watch de archivos del sistema
```

### **B√∫squeda y Filtrado**

```go
// B√∫squeda fuzzy
github.com/sahilm/fuzzy v0.1.1           // Algoritmo fuzzy matching para filtros

// Ordenamiento
github.com/fvbommel/sortorder v1.1.0     // Ordenamiento natural (ej: file1, file10, file2)
```

### **Colores y Styling**

```go
// Sistema de colores
github.com/fatih/color v1.18.0           // Colores ANSI en terminal
github.com/lmittmann/tint v1.0.7         // Colores para logging estructurado
```

### **CLI y Comandos**

```go
// Framework CLI
github.com/spf13/cobra v1.9.1            // Framework de l√≠nea de comandos

// Expresiones y queries
github.com/itchyny/gojq v0.12.17         // Implementaci√≥n de jq en Go
```

### **Renderizado de Tablas**

```go
// Renderizado de datos tabulares
github.com/olekukonko/tablewriter v1.0.8 // Generaci√≥n de tablas ASCII
```

### **Utilidades de Sistema**

```go
// Manejo de errores
github.com/go-errors/errors v1.5.1       // Stack traces mejorados

// Backoff y retry
github.com/cenkalti/backoff/v4 v4.3.0    // Algoritmos de backoff exponencial

// Texto y Unicode
golang.org/x/text v0.27.0                // Soporte completo de Unicode
```

### **Ejemplo de Imports T√≠picos en k9s**

```go
// Archivo t√≠pico de UI component
package ui

import (
    "context"
    "sync"
    
    "github.com/derailed/k9s/internal/config"
    "github.com/derailed/k9s/internal/model"
    "github.com/derailed/tcell/v2"        // Control de eventos de teclado
    "github.com/derailed/tview"           // Componentes TUI
)

// Archivo t√≠pico de vista
package view

import (
    "github.com/derailed/k9s/internal/ui"
    "github.com/derailed/k9s/internal/client"
    "github.com/derailed/k9s/internal/render"
    "github.com/sahilm/fuzzy"             // B√∫squeda fuzzy
    "gopkg.in/yaml.v3"                    // Configuraci√≥n YAML
)
```

### **Dependencias Clave para Replicar**

Para crear una TUI similar, necesitar√°s estos m√≥dulos esenciales:

```bash
# M√≥dulos TUI principales
go get github.com/rivo/tview            # (o usar el fork derailed/tview)
go get github.com/gdamore/tcell/v2      # (o usar el fork derailed/tcell)

# Configuraci√≥n y archivos
go get gopkg.in/yaml.v3
go get github.com/xeipuuv/gojsonschema
go get github.com/fsnotify/fsnotify

# B√∫squeda y filtrado
go get github.com/sahilm/fuzzy
go get github.com/fvbommel/sortorder

# Colores y CLI
go get github.com/fatih/color
go get github.com/spf13/cobra

# Utilidades
go get github.com/atotto/clipboard
go get github.com/mattn/go-runewidth
go get github.com/cenkalti/backoff/v4
```

### **Notas Importantes sobre los Forks**

k9s utiliza **forks personalizados** de las bibliotecas principales:

1. **`github.com/derailed/tview`** (fork de `rivo/tview`)
   - A√±ade funcionalidades espec√≠ficas para k9s
   - Mejoras en el manejo de eventos
   - Componentes personalizados

2. **`github.com/derailed/tcell/v2`** (fork de `gdamore/tcell`)
   - Optimizaciones de rendimiento
   - Soporte mejorado para diferentes terminales
   - Manejo espec√≠fico de eventos de teclado

Estos forks proporcionan funcionalidades adicionales que no est√°n en las versiones originales, por lo que para replicar completamente la funcionalidad de k9s, podr√≠as necesitar usar los forks o implementar funcionalidades similares.

### 2. **Estructura de Proyecto**

```
proyecto/
‚îú‚îÄ‚îÄ cmd/                 # Comando principal
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ ui/             # Componentes UI b√°sicos
‚îÇ   ‚îú‚îÄ‚îÄ view/           # Vistas espec√≠ficas  
‚îÇ   ‚îú‚îÄ‚îÄ render/         # Sistema de renderizado
‚îÇ   ‚îú‚îÄ‚îÄ config/         # Configuraci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ model/          # Modelos y estado
‚îÇ   ‚îî‚îÄ‚îÄ theme/          # Gesti√≥n de temas
‚îú‚îÄ‚îÄ assets/             # Recursos est√°ticos
‚îú‚îÄ‚îÄ skins/              # Temas predefinidos
‚îî‚îÄ‚îÄ configs/            # Configuraciones base
```

### 3. **Testing Strategy**
- Tests unitarios para cada componente
- Tests de integraci√≥n para flujos completos
- Tests de UI con simulaci√≥n de eventos
- Benchmarks para rendimiento de renderizado

### 4. **Performance Considerations**
- Lazy loading de datos grandes
- Virtualizaci√≥n de listas largas
- Debouncing para filtros en tiempo real
- Pool de objetos para reducir GC pressure
- Renderizado incremental

## üé® Elementos de UX Avanzados

### 1. **Feedback Visual**
- Spinners para operaciones largas
- Barras de progreso para transferencias
- Flasheos para notificaciones
- Colores sem√°nticos (verde=ok, rojo=error, amarillo=warning)

### 2. **Navegaci√≥n Intuitiva**
- Breadcrumbs para mostrar contexto
- Historial de navegaci√≥n (adelante/atr√°s)
- Shortcuts para vistas frecuentes
- Status bar informativo

### 3. **Accesibilidad**
- Soporte completo de teclado
- Indicadores visuales claros
- Mensajes de error descriptivos
- Hints contextuales

## üîç Detalles de Implementaci√≥n k9s

### Componentes Clave Analizados

#### 1. **Aplicaci√≥n Principal (`internal/ui/app.go`)**
- Gesti√≥n centralizada de eventos de teclado
- Sistema de vistas registradas con mapa
- Buffer de comandos con listener pattern
- Configurador de estilos integrado

#### 2. **Sistema de P√°ginas (`internal/ui/pages.go`)**
- Integraci√≥n con tview.Pages
- Stack para navegaci√≥n hacia atr√°s
- Detecci√≥n autom√°tica de di√°logos
- Gesti√≥n de componentes activos

#### 3. **Tabla Avanzada (`internal/ui/table.go`)**
- Selecci√≥n m√∫ltiple con marcadores
- Filtrado fuzzy en tiempo real
- Ordenamiento din√°mico
- Coloreado contextual por estado

#### 4. **Sistema de Renderizado (`internal/render/`)**
- Renderizadores espec√≠ficos por recurso (Pod, Service, etc.)
- Funciones de coloreado personalizables
- Headers din√°micos con metadatos
- Formateo inteligente de datos

#### 5. **Configuraci√≥n Din√°mica (`internal/config/`)**
- Carga de skins desde YAML
- Hotkeys personalizables
- Aliases de comandos
- Validaci√≥n con JSON Schema

#### 6. **Gesti√≥n de Eventos (`internal/ui/key.go`)**
- Mapeo completo de teclas (est√°ndar, shift, ctrl)
- Acciones jer√°rquicas con propagaci√≥n
- Sistema de hints contextual
- Soporte para combinaciones complejas

## üìã Checklist de Implementaci√≥n

### Fase 1: Base
- [ ] Configurar proyecto Go con tview/tcell
- [ ] Implementar App principal con Pages
- [ ] Sistema b√°sico de eventos de teclado
- [ ] Configuraci√≥n YAML b√°sica

### Fase 2: Componentes Core
- [ ] Tabla con filtrado y selecci√≥n
- [ ] Sistema de di√°logos modales
- [ ] Prompt con autocompletado
- [ ] Menu din√°mico de acciones

### Fase 3: Avanzado
- [ ] Sistema de skins/temas
- [ ] Hotkeys personalizables
- [ ] Sistema de renderizado modular
- [ ] Gesti√≥n de estado con observers

### Fase 4: Polish
- [ ] Testing exhaustivo
- [ ] Performance optimization
- [ ] Documentaci√≥n de usuario
- [ ] Temas predefinidos

## üéì Lecciones Clave de k9s

1. **Modularidad:** Cada componente tiene responsabilidades claras
2. **Configurabilidad:** Todo es personalizable sin recompilaci√≥n
3. **Extensibilidad:** Sistema de plugins y extenders
4. **Performance:** Actualizaciones as√≠ncronas y renderizado eficiente
5. **UX:** Feedback visual constante y navegaci√≥n intuitiva

---

## üéØ Ejemplo Pr√°ctico: Gmail TUI

### Implementaci√≥n Real del Sistema de Colores

Para demostrar c√≥mo aplicar estos conceptos, aqu√≠ est√° la implementaci√≥n real del sistema de colores en nuestro Gmail TUI:

#### **1. Configuraci√≥n de Tema** (`skins/gmail-dark.yaml`):
```yaml
gmailTUI:
  body:
    fgColor: "#f8f8f2"
    bgColor: "#282a36"
    logoColor: "#bd93f9"
  
  frame:
    border:
      fgColor: "#44475a"
      focusColor: "#6272a4"
    
    title:
      fgColor: "#f8f8f2"
      bgColor: "#282a36"
      highlightColor: "#f1fa8c"
      counterColor: "#50fa7b"
      filterColor: "#8be9fd"

  views:
    table:
      fgColor: "#f8f8f2"
      bgColor: "#282a36"
      headerFgColor: "#50fa7b"
      headerBgColor: "#282a36"

  # Colores espec√≠ficos para emails
  email:
    unreadColor: "#ffb86c"      # Naranja para no le√≠dos
    readColor: "#6272a4"        # Gris para le√≠dos
    importantColor: "#ff5555"   # Rojo para importantes
    sentColor: "#50fa7b"        # Verde para enviados
    draftColor: "#f1fa8c"       # Amarillo para borradores
```

#### **2. Renderizador de Emails** (`internal/render/email.go`):
```go
package render

import (
    "strings"
    "github.com/gdamore/tcell/v2"
    "github.com/yourusername/gmail-tui/internal/gmail"
)

// EmailColorer maneja los colores de emails
type EmailColorer struct {
    UnreadColor    tcell.Color
    ReadColor      tcell.Color
    ImportantColor tcell.Color
    SentColor      tcell.Color
    DraftColor     tcell.Color
}

// ColorerFunc devuelve funci√≥n de coloreo para emails
func (ec *EmailColorer) ColorerFunc() func(*gmail.Email, string) tcell.Color {
    return func(email *gmail.Email, column string) tcell.Color {
        switch strings.ToUpper(column) {
        case "STATUS":
            if email.IsUnread {
                return ec.UnreadColor  // üîµ Azul para no le√≠do
            }
            return ec.ReadColor        // ‚ö™ Gris para le√≠do
            
        case "FROM":
            if email.IsImportant {
                return ec.ImportantColor  // üî¥ Rojo para importante
            }
            if email.IsUnread {
                return ec.UnreadColor     // üü† Naranja para no le√≠do
            }
            return tcell.ColorWhite
            
        case "SUBJECT":
            if contains(email.Labels, "DRAFT") {
                return ec.DraftColor      // üü° Amarillo para borrador
            }
            if contains(email.Labels, "SENT") {
                return ec.SentColor       // üü¢ Verde para enviado
            }
            if email.IsUnread {
                return tcell.ColorWhite   // ‚ö™ Blanco brillante
            }
            return ec.ReadColor           // ‚ö´ Gris para le√≠do
        }
        return tcell.ColorWhite
    }
}

// UpdateFromStyles actualiza colores desde configuraci√≥n
func (ec *EmailColorer) UpdateFromStyles(styles *config.Styles) {
    ec.UnreadColor = styles.Email.UnreadColor.Color()
    ec.ReadColor = styles.Email.ReadColor.Color()
    ec.ImportantColor = styles.Email.ImportantColor.Color()
    ec.SentColor = styles.Email.SentColor.Color()
    ec.DraftColor = styles.Email.DraftColor.Color()
}
```

#### **3. Aplicaci√≥n en EmailList** (`internal/view/email_list.go`):
```go
// updateTable aplica colores din√°micos a cada fila
func (el *EmailList) updateTable() {
    // Limpiar filas existentes
    for i := el.GetRowCount() - 1; i > 0; i-- {
        el.RemoveRow(i)
    }

    colorer := el.colorer.ColorerFunc()
    
    for i, email := range el.emails {
        row := i + 1
        
        // Aplicar colores espec√≠ficos por columna
        statusColor := colorer(email, "STATUS")
        fromColor := colorer(email, "FROM")
        subjectColor := colorer(email, "SUBJECT")
        dateColor := tcell.ColorGray
        
        // Crear celdas con colores apropiados
        statusText := " "
        if email.IsUnread {
            statusText = "‚óè"
        }
        
        el.SetCell(row, 0, tview.NewTableCell(statusText).
            SetTextColor(statusColor).
            SetAlign(tview.AlignCenter))
            
        el.SetCell(row, 1, tview.NewTableCell(el.truncateString(email.From, 25)).
            SetTextColor(fromColor))
            
        el.SetCell(row, 2, tview.NewTableCell(el.truncateString(email.Subject, 50)).
            SetTextColor(subjectColor))
            
        el.SetCell(row, 3, tview.NewTableCell(el.formatDate(email.Date)).
            SetTextColor(dateColor).
            SetAlign(tview.AlignRight))
    }
}

// StylesChanged reacciona a cambios de tema
func (el *EmailList) StylesChanged(s *config.Styles) {
    // Actualizar colores del renderizador
    el.colorer.UpdateFromStyles(s)
    
    // Refrescar toda la tabla
    el.app.QueueUpdateDraw(func() {
        el.updateTable()
    })
}
```

#### **4. Resultado Visual:**

```
‚îå‚îÄ Emails ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Status ‚îÇ From              ‚îÇ Subject                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   üîµ‚óè  ‚îÇ John Doe          ‚îÇ Meeting tomorrow            ‚îÇ <- No le√≠do (naranja)
‚îÇ   ‚ö™   ‚îÇ Jane Smith        ‚îÇ Project update              ‚îÇ <- Le√≠do (gris)
‚îÇ   üî¥‚óè  ‚îÇ Boss              ‚îÇ URGENT: Review needed       ‚îÇ <- Importante (rojo)
‚îÇ   üü¢   ‚îÇ Me                ‚îÇ Re: Vacation request        ‚îÇ <- Enviado (verde)
‚îÇ   üü°   ‚îÇ Draft             ‚îÇ Email draft                 ‚îÇ <- Borrador (amarillo)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Beneficios Reales

‚úÖ **Informaci√≥n visual instant√°nea** - Los usuarios ven el estado sin leer texto  
‚úÖ **Consistencia** - Mismos colores en toda la aplicaci√≥n  
‚úÖ **Personalizaci√≥n** - Cada usuario puede tener su tema preferido  
‚úÖ **Accesibilidad** - Soporte para diferentes esquemas de color  
‚úÖ **Escalabilidad** - F√°cil a√±adir nuevos estados y colores

---

Esta gu√≠a captura la esencia de la arquitectura TUI de k9s y proporciona un roadmap detallado para implementar interfaces similares en otros proyectos. La clave est√° en la modularidad, la configurabilidad y la atenci√≥n al detalle en la experiencia de usuario.

**¬°√âxito construyendo tu TUI profesional con sistema de colores din√°mico!** üöÄ
